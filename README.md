# cocoCoin
java 公链区块连示例，参考比特币

## 1.为何要自己实现
研究了很久的区块链，略读了比特币源码；自以为懂了使用的业务场景，懂了区块链细节。对于团队协作来说，最好的程序员是善于协作使用轮子。不过对于学习来说，最好的学习方式就是造一个轮子。因此参考比特币实现基本的区块链，彻底处理好对应的细节。

## 2.主要业务点
实现基础功能的比特币，支持加解密、交易、链、p2p、挖矿<br>
a.账户使用utxo<br>
b.每笔交易支持单地址支付(可以多个输入token)<br>
c.共识机制：pow<br>
d.解锁脚本和锁定脚本:不支持。通过固定的规则<br>

不处理点：<br>
a.地址转换，只支持一种地址格式<br>
b.地址校验：不校验<br>
c.交易的默克尔hash<br>
d.难度调整：固定难度调整<br>
e.挖矿币:固定数量<br>

## 3.结构
参考比特币核心架构


## 4.存储结构
在区块链中，数据不可更改。存储结构的格式需要尽量少改变，因此存储结构需要支持未来的变化。在未来变化时，历史数据能够不需要改变<br>

存储格式：二进制，编码：高位在前，低位在后<br>

hash长度以及算法定义<br>
a.32位hash，采用md5计算<br>
b.64为hash，采用sha-256计算<br>
c.128位hash,采用sha-512计算<br>

block:{<br>
    magic(4)  //魔法字<br>
    version(4)//版本<br>
    hight(4)   //当前高度<br>
    hash(128)//上一块的hash值<br>
    nonce(4)//随机数，用来执行pow算法<br>
    length(4) //块长(包含魔法字等在内的总长度)<br>
    count(4)//交易数<br>
    hash(128)://交易打包后的hash值<br>
    trans  //交易内容链（变长）<br>
}<br>

<br>
trans:[{ <br>      
       
   tran://交易内容(变长){<br>
            length(4), 交易长度，包含自身长度<br>
            version(4)//版本<br>
            hash(64)://交易hash值，包括签名在内(不包括版本和交易长度)，可作为交易的id<br>
            inputCount(4) 输入数量（长度可以为2，暂时不考虑存储，先4）<br>
            outputCount(4)输出数量，同输入数量<br>
            publicKey(162)：公钥, 因为一个交易只有一个公钥，因此输入只能来自同一个地址的币做处理，(如果byte存储直接公钥为162，base64专门后为216)<br>
            signLength(4)， sign长度            <br>
            sign，解锁脚本--交易签名(所有输入和输出+时间戳的签名)<br>
            {<br>
               输入：<br>
                [{<br>
                    inputHash(64),   (输入的交易id，指上一交易对应的hash)<br>
                    index(4):输入序号(对应上一交易的输出序号)<br>
                }],<br>
                输出：<br>
                [{                    <br>
                    addr(32),输出地址，通过接收方的公钥hash计算得出<br>
                    count(4), 币的数量数量<br>
                }]<br>
            }<br>
            validHash(32), sign通过公钥解密后内容的md5值（用来对解锁内容做校验）。<br>
            timestamp(4) 时间戳<br>
        }<br>
    }]<br>
